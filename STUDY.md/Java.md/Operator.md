# 2. 연산자

: 연산자란 어떤 연산을 할지를 결정하는 기호 ex) x , + , - …

## 1) 산술 연산자

: 사칙연산, 즉 간단한 수학 연산

**연산자** 

 \+ : 더한 값을 반환  

 \- : 뺀 값을 반환 

 \* : 곱한 값을 반환 

 / : 나눈 값을 반환 

 % : 나머지를 반환 (모듈러) 

```java
int result = (10+5%3)/ 3+2*3;

=> 괄호-> 곱셈,나눗셈 모듈러-> 덧셈,뺄셈 
```

### 1-1) 형변환(Type Casting)

- 작은 걸 큰 것에 넣을 때 묵시적 형변환 (자동으로 변환함)

  **byte→ short → int → long → float → double**

- 더 큰 자료형에서 작은 자료형을 변환할 때는 수동으로 형 변환을 해줘야 한다. → 명시적 형변환 (데이터 손실이 있을 수 있으니 주의) 

### 1-2) 증감 연산자

: 대상 피연산자의 값을 1 증가하거나 감소시키는 연산자

| 연산자 | 설명 |
| --- | --- |
| ++ | 피연산자의 값을 1 증가시킨다. |
| - - | 피연산자의 값을 1 감소시킨다. |

** 앞에도 불일 수 있고, 뒤에도 불일 수 있다. 

```java
int count = 20;
System.out.println(++count); // 출력 21 (출력전에 1증가, 값:21)
System.out.println(count++); // 출력 21 (출력전에 1증가, 값:22)
System.out.println(--count); // 출력 21 (출력전에 1증가, 값:21)
System.out.println(count--); // 출력 21 (출력전에 1증가, 값:20)
```

### 1-3) 복합 할당 연산자

: 할당 연산자(=)와 다른 산술 연산자를 합친 복합 할당 연산자

| 연산자 | 사용 | 비교 |
| --- | --- | --- |
| = |  |  |
| += | a + = 10; | a = a+ 10; |
| -= | a -=  10; | a = a- 10; |
| *= | a *= 10; | a = a*10; |
| /= | a /= 10; | a = a/ 10; |
| %= | a %= 10; | a = a% 10; |

## 2) 비교 연산자

: 두 피연산자의 대소를 ㅂ교하여 boolean 을 반환하는 연산자

| 연산자 | 설명 |
| --- | --- |
| == | 양쪽 피연산자가 같으면 참, 다르면 거짓을 반환한다. |
| ! = | 양쪽 피연산자가 다르면 참, 같으면 거짓을 반환한다. |
| > | 왼쪽의 피연산자가 오른쪽 피연산자 보다 크면 참, 작거나 같으면 거짓을 반환한다. |
| > = | 왼쪽의 피연산자가 오른쪽 피연산자 보다 크거나 같으면 참, 작으면 거짓을 반환한다. |
| < | 왼쪽의 피연산자가 오른쪽 피연산자 보다 작으면 참, 크거나 같으면 거짓을 반환한다. |
| < = | 왼쪽의 피연산자가 오른쪽 피연산자 보다 작거나 같으면 참, 크면 거짓을 반환한다. |

**문자열의 비교**

두 문자열을 비교할때는, 비교 연산자 ‘==’ 대신 equals()라는 메서드를 사용해야 한다. 비교 연산자(==)는 두 문자열이 완전히 같은지 비교할뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것이다. 

### 1-1) 논리 연산자

: 두가지 조건 (boolean)에 대하여, 두 조건의 참-거짓의 조합에 따라 boolean 결과를 반환한다.

| 연산자 | 설명 |
| --- | --- |
| && | 양쪽의 피연산자가 모두 참일때 참, 아니면 거짓을 반환 |
| || | 양쪽의 피연산자 중 하나라도 참일 때 참, 아니면 거짓을 반환 |
| ! | 피연산자가 참이면 거짓, 거짓이면 참을 반환한다(부정) |

## 3) 비트 연산자

: 데이터를 비트 단위로 계산하는 연산자

**-AND 연산 (&)**

- 피연산자의 각 자리의 비트를 비교
- 두 비트가 모두 1이면 결과의 비트도 1
- 아니면 0

**-OR 연산 (|)**

- 피연산자의 각 자리의 비트를 비교
- 두 비트 중 하나라도 1이면 결과의 비트도 1
- 아니면 0

**-XOR연산 (^)**

- 피연산자의 각 자리의 비트를 비교
- 두 비트가 서로 다르면 1
- 서로 같으면 0

**-NOT 연산 (~)**

- 피연산자의 각 비트를 반대로 반환
- 0→1, 1→0

**-SHIFT연산 (<<,>>,>>>)**

- 비트를 왼쪽 또는 오른쪽으로 이동
- 왼쪽 피연산자를 오른쪽 숫자만큼 이동
- 비트 범위를 넘어가면 버려진다.

**-LEFT SHIFT 연산 (<<)**

- 비트를 왼쪽으로 이동
- 비어버린 비트는 0으로 채운다.

**-RIGHT SHIFT 연산 (>>, >>>)**

- 비트를 오른쪽으로 이동
- 비어버린 비트를 부호를 유지하며 채운다.
- 본래 왼족 비트가 1이면 1로, 0이면 0으로

**-삼항 연산자**

: 하나의 조건이, 참인지 거짓인지에 따라 두가지 값 중 하나를 결정하는 연산자.

조건 하나와 후보가 되는 값 두개가 필요해서, 3개의 항이 필요하다.

```java
int temperature = 37;S
String message = temperature < 38? "OK" : "Fever";
```

예제1.

```java
public class operator {

    public static void main(String[] args) {
        int a=4, b=5, c=6;
        System.out.println(false && a-- > 6);  //false
        System.out.println(true | b++ > 6);    //true
        System.out.println(true ^ c++ > 6);    //true
        System.out.println(a);                 //4
        System.out.println(b);                 //6
        System.out.println(c);                 //7
    }
}
```

예제2.

```java
public class operator {

    public static void main(String[] args) {
        int a = 3;
        a <<= 1;
        System.out.println(a);  //6
        a &= 5;
        System.out.println(a);  //4
        a -= 1;
        System.out.println(a *= 2);  //6
    }
}
```